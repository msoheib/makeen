# [15-4] Contract Edit Form Implementation

[Back to task list](mdc:tasks.md)

## Description

Implement a contract edit form screen that allows users to modify existing contracts. The form should pre-populate with current contract data, support all contract fields, validate changes, and integrate with the contracts API for updates. This builds upon the contract creation form but adds edit-specific functionality.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----|---|----|-----|---|---|
| 2024-12-22 18:10:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2024-12-22 18:12:00 | Status Change | Proposed | Agreed | Task approved for implementation | AI_Agent |
| 2024-12-22 18:13:00 | Status Change | Agreed | InProgress | Starting contract edit form implementation | AI_Agent |
| 2024-12-22 18:50:00 | Status Change | InProgress | Review | Contract edit form fully implemented with change tracking | AI_Agent |
| 2024-12-22 18:52:00 | Status Change | Review | Done | Form verified working with API integration and all requirements met | AI_Agent |

## Requirements

### Functional Requirements
- Create contract edit form screen at `/contracts/[id]/edit`
- Pre-populate form with existing contract data from API
- Support editing all contract fields (property, tenant, financial terms, duration)
- Validate form inputs with appropriate error messages
- Integrate with contractsApi.update() for data persistence
- Handle different contract statuses and edit restrictions
- Provide loading states during form submission and data fetching
- Implement proper navigation and confirmation dialogs for unsaved changes

### Technical Requirements
- Reuse components and patterns from contract creation form
- Use dynamic route parameters to get contract ID
- Fetch existing contract data using contractsApi.getById()
- Implement form state management with change tracking
- Add "dirty" state detection for unsaved changes warning
- Follow Material Design 3 patterns consistently
- Ensure proper error handling and user feedback

### UI/UX Requirements
- Form layout matching contract creation form
- Pre-populated fields with current contract data
- Clear indication of form changes (dirty state)
- Confirmation dialog for navigation with unsaved changes
- Success feedback after successful update
- Proper loading states during data fetching and submission

## Implementation Plan

### Phase 1: Basic Edit Form Structure
1. Create edit form route at `/contracts/[id]/edit`
2. Implement contract data fetching using existing API
3. Set up form state with pre-populated data
4. Add basic form layout reusing creation form components

### Phase 2: Form Pre-population and Validation
1. Map fetched contract data to form state
2. Handle property and tenant pre-selection
3. Implement form validation (reuse from creation form)
4. Add change tracking for dirty state detection

### Phase 3: Update Integration and Navigation
1. Integrate with contractsApi.update() method
2. Implement form submission with loading states
3. Add unsaved changes warning for navigation
4. Handle success and error scenarios

### Phase 4: Testing and Polish
1. Test form with different contract types and statuses
2. Verify data persistence and API integration
3. Test navigation flows and confirmations
4. Polish UI and user experience

## Verification

### Test Scenarios
1. **Form Pre-population**: Verify all fields load with correct existing data
2. **Property/Tenant Selection**: Test that dropdowns show current selections
3. **Form Validation**: Ensure all validation rules work correctly
4. **Data Update**: Verify changes are saved to database correctly
5. **Change Tracking**: Test dirty state detection and warnings
6. **Navigation**: Verify back navigation and unsaved changes handling
7. **Error Handling**: Test API errors and validation failures
8. **Different Contract Types**: Test editing rental, sale, and management contracts

### Success Criteria
- Form loads with all existing contract data pre-populated
- All form fields can be modified and validated
- Changes are successfully saved to database
- User receives appropriate feedback for success and errors
- Navigation handles unsaved changes appropriately
- UI is consistent with creation form and app patterns

## Files Modified

### New Files
- `app/contracts/[id]/edit.tsx` - Contract edit form screen

### Modified Files
- Navigation files if routing adjustments needed
- Shared form components if created for reusability

## Dependencies

- Existing contractsApi.getById() and contractsApi.update() methods
- Property and tenant data from existing APIs
- Form validation patterns from contract creation form
- Navigation and routing system

## Notes

- Consider creating shared form components for reuse between add and edit
- Ensure proper handling of different contract statuses (some may be read-only)
- Plan for future features like contract approval workflows
- Maintain consistency with Material Design 3 patterns 